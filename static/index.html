<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Grid</title>
<style>
  html,body{height:100%;margin:0}
  #c{display:block;width:100%;height:100%}
</style>
</head>
<body>
<div id="ui" style="position:absolute;top:8px;left:8px;z-index:10;background:#fff;border:1px solid #ccc;border-radius:6px;padding:6px 8px;font:13px/1.3 system-ui,Segoe UI,Arial;display:flex;gap:6px;align-items:center">
  <select id="mapSel"></select>
  <input id="newMap" placeholder="new id (4 letters)" maxlength="4" style="width:120px" />
  <button id="createBtn">Create</button>
  <button id="deleteBtn">Delete</button>
</div>
<canvas id="c"></canvas>
<script>
const canvas=document.getElementById('c')
const ctx=canvas.getContext('2d')
let dpr=window.devicePixelRatio||1
function size(){const r=canvas.getBoundingClientRect();canvas.width=Math.max(1,Math.round(r.width*dpr));canvas.height=Math.max(1,Math.round(r.height*dpr));}
const tile=64
const MAX_SELECTION=15
const Z=8
let MAP_ID='difq'
const tiles=new Map()
function key(x,y){return x+','+y}
let zoom=0
let originX=0
let originY=0
let panActive=false
let lastX=0,lastY=0
let isSpaceDown=false
let selecting=false
let selectionStart=null
let selectionRect=null
let highlightRect=null
let generating=false
let lastPrompt=''
function isEditableTarget(t){if(!t)return false;const tag=(t.tagName||'').toLowerCase();return tag==='input'||tag==='textarea'||tag==='select'||t.isContentEditable}
function tileFromClient(clientX,clientY){const rect=canvas.getBoundingClientRect();const mx=clientX-rect.left;const my=clientY-rect.top;const scale=Math.pow(2,zoom);const wx=(mx-originX)/scale;const wy=(my-originY)/scale;return{x:Math.floor(wx/tile),y:Math.floor(wy/tile)}}
function updateSelection(current){if(!selectionStart)return;const maxOffset=MAX_SELECTION-1;const dx=Math.max(-maxOffset,Math.min(maxOffset,current.x-selectionStart.x));const dy=Math.max(-maxOffset,Math.min(maxOffset,current.y-selectionStart.y));const endX=selectionStart.x+dx;const endY=selectionStart.y+dy;const minX=Math.min(selectionStart.x,endX);const minY=Math.min(selectionStart.y,endY);const width=Math.abs(endX-selectionStart.x)+1;const height=Math.abs(endY-selectionStart.y)+1;selectionRect={x:minX,y:minY,width,height}}
function draw(){const r=canvas.getBoundingClientRect();ctx.setTransform(dpr,0,0,dpr,0,0);ctx.clearRect(0,0,r.width,r.height);const scale=Math.pow(2,zoom);const spacing=tile*scale;ctx.strokeStyle='rgba(0,0,0,0.25)';ctx.lineWidth=1;let startX=originX%spacing;if(startX<0)startX+=spacing;for(let x=startX;x<=r.width;x+=spacing){ctx.beginPath();ctx.moveTo(Math.round(x)+0.5,0);ctx.lineTo(Math.round(x)+0.5,r.height);ctx.stroke()}let startY=originY%spacing;if(startY<0)startY+=spacing;for(let y=startY;y<=r.height;y+=spacing){ctx.beginPath();ctx.moveTo(0,Math.round(y)+0.5);ctx.lineTo(r.width,Math.round(y)+0.5);ctx.stroke()}tiles.forEach(v=>{const sx=Math.round(originX+v.x*tile*scale);const sy=Math.round(originY+v.y*tile*scale);const sz=Math.round(tile*scale);ctx.drawImage(v.img,sx,sy,sz,sz)});const rect=selectionRect||highlightRect;if(rect){const baseX=originX+rect.x*tile*scale;const baseY=originY+rect.y*tile*scale;const w=rect.width*tile*scale;const h=rect.height*tile*scale;ctx.fillStyle=generating?'rgba(79,140,255,0.15)':'rgba(79,140,255,0.25)';ctx.strokeStyle=generating?'rgba(79,140,255,0.7)':'rgba(79,140,255,0.85)';ctx.lineWidth=Math.max(1,Math.min(3,scale));ctx.fillRect(baseX,baseY,w,h);ctx.strokeRect(baseX+0.5,baseY+0.5,w,h)}}
window.addEventListener('resize',()=>{size();draw()})
window.addEventListener('keydown',e=>{if(isEditableTarget(e.target))return;if(e.code==='Space'){if(!isSpaceDown)e.preventDefault();isSpaceDown=true}if(e.key==='Escape'){if(selecting){selecting=false;selectionRect=null}else{highlightRect=null}draw()}})
window.addEventListener('keyup',e=>{if(isEditableTarget(e.target))return;if(e.code==='Space')isSpaceDown=false})
function pointInRect(pt,rect){if(!rect)return false;return pt.x>=rect.x&&pt.y>=rect.y&&pt.x<rect.x+rect.width&&pt.y<rect.y+rect.height}
canvas.addEventListener('mousedown',e=>{if((e.button===0&&isSpaceDown)||e.button===1||e.button===2){panActive=true;lastX=e.clientX;lastY=e.clientY;e.preventDefault();return}if(e.button!==0)return;const pt=tileFromClient(e.clientX,e.clientY);if(highlightRect){if(pointInRect(pt,highlightRect)){requestGeneration(highlightRect);e.preventDefault();return}else{highlightRect=null;draw();e.preventDefault();return}}selecting=true;selectionStart=pt;selectionRect={x:pt.x,y:pt.y,width:1,height:1};draw();e.preventDefault()})
window.addEventListener('mousemove',e=>{if(panActive){originX+=e.clientX-lastX;originY+=e.clientY-lastY;lastX=e.clientX;lastY=e.clientY;draw();return}if(!selecting)return;updateSelection(tileFromClient(e.clientX,e.clientY));draw()})
window.addEventListener('mouseup',e=>{if(panActive&&(e.button===0||e.button===1||e.button===2))panActive=false;if(selecting&&e.button===0)finalizeSelection()})
canvas.addEventListener('contextmenu',e=>e.preventDefault())
canvas.addEventListener('wheel',e=>{e.preventDefault();const rect=canvas.getBoundingClientRect();const mx=e.clientX-rect.left;const my=e.clientY-rect.top;const prevScale=Math.pow(2,zoom);const step=e.deltaY<0?0.25:-0.25;zoom=Math.min(6,Math.max(-6,zoom+step));const scale=Math.pow(2,zoom);originX=mx-(mx-originX)*(scale/prevScale);originY=my-(my-originY)*(scale/prevScale);draw()},{passive:false})
async function loadTiles(infos){if(!Array.isArray(infos)||!infos.length)return;const tasks=infos.map(info=>new Promise(resolve=>{const img=new Image();img.onload=()=>{tiles.set(key(info.x,info.y),{img,x:info.x,y:info.y});resolve()};img.onerror=()=>{console.warn('tile load failed',info);resolve()};img.src=`${info.url}?t=${Date.now()}`;}));await Promise.all(tasks)}
async function hydrateExisting(){try{const r=await fetch(`/maps/${MAP_ID}/tiles/${Z}`);if(!r.ok)return;const j=await r.json().catch(()=>null);if(!j||!Array.isArray(j.tiles))return;await loadTiles(j.tiles);draw()}catch(err){console.warn('hydrate failed',err)}}
async function requestGeneration(rect,del=false){const copy={...rect};let text='';if(!del){const promptText=window.prompt(`Prompt for ${copy.width}x${copy.height}`,lastPrompt);if(promptText===null){draw();return}text=promptText.trim();if(text)lastPrompt=text}highlightRect=copy;draw();try{const res=await fetch(`/maps/${MAP_ID}/generate`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({x:copy.x,y:copy.y,width:copy.width,height:copy.height,z:Z,prompt:text,delete:del})});const json=await res.json().catch(()=>null);if(!res.ok||!json||json.ok!==true){alert('Generation failed');return}if(Array.isArray(json.tiles)&&json.tiles.length){await loadTiles(json.tiles)}if(Array.isArray(json.removed)&&json.removed.length){json.removed.forEach(t=>{tiles.delete(key(t.x,t.y))})}draw()}catch(err){alert('Generation error')}finally{highlightRect=null;draw()}}
function finalizeSelection(){const rect=selectionRect?{...selectionRect}:null;selecting=false;selectionStart=null;selectionRect=null;if(!rect){draw();return}highlightRect=rect;draw()}
size();draw()

async function refreshMaps(){
  try{const r=await fetch('/maps');if(!r.ok)return;const j=await r.json().catch(()=>null);if(!j||!Array.isArray(j.maps))return;const sel=document.getElementById('mapSel');sel.innerHTML='';j.maps.forEach(id=>{const o=document.createElement('option');o.value=id;o.textContent=id;if(id===MAP_ID)o.selected=true;sel.appendChild(o)});sel.onchange=()=>{MAP_ID=sel.value;tiles.clear();selectionRect=null;highlightRect=null;draw();hydrateExisting()}}catch(err){console.error('map refresh failed',err)}}
document.getElementById('createBtn').onclick=async()=>{const v=(document.getElementById('newMap').value||'').trim().toLowerCase();if(!/^[a-z]{4}$/.test(v))return alert('4 letters');const r=await fetch('/maps',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({map_id:v})});const j=await r.json().catch(()=>({ok:false}));if(j.ok){MAP_ID=v;tiles.clear();selectionRect=null;highlightRect=null;document.getElementById('newMap').value='';refreshMaps();draw()}}
refreshMaps();hydrateExisting();
document.getElementById('deleteBtn').onclick=async()=>{if(!highlightRect){alert('No selection');return}const ok=window.confirm('Delete selected tiles?');if(!ok)return;await requestGeneration(highlightRect,true)}
</script>
</body>
</html>
