<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Grid</title>
<style>
  html,body{height:100%;margin:0}
  #c{display:block;width:100%;height:100%}
</style>
</head>
<body>
<div id="ui" style="position:absolute;top:8px;left:8px;z-index:10;background:#fff;border:1px solid #ccc;border-radius:6px;padding:6px 8px;font:13px/1.3 system-ui,Segoe UI,Arial;display:flex;gap:6px;align-items:center">
  <select id="mapSel"></select>
  <input id="newMap" placeholder="new id (4 letters)" maxlength="4" style="width:120px" />
  <button id="createBtn">Create</button>
  <button id="deleteBtn">Delete</button>
  <button id="animateBtn">Animate</button>
  <button id="playBtn" disabled>Play</button>
</div>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let dpr = window.devicePixelRatio || 1;

const TILE_SIZE = 64;
const MAX_SELECTION = 15;
const Z = 8;
let MAP_ID = 'difq';

const tiles = new Map();
const animationManifest = new Map();
const animationFrames = new Map();

const animateBtn = document.getElementById('animateBtn');
const playBtn = document.getElementById('playBtn');
const mapSelect = document.getElementById('mapSel');

const DEFAULT_FRAME_MS = 120;
const FRAME_COUNT = 16;

let zoom = 0;
let originX = 0;
let originY = 0;
let panActive = false;
let lastX = 0;
let lastY = 0;
let isSpaceDown = false;
let selecting = false;
let selectionStart = null;
let selectionRect = null;
let highlightRect = null;
let generating = false;
let lastPrompt = '';
let animationBusy = false;
let lastAnimationPrompt = '';

let activeAnimation = null;
let animationFrameHandle = null;

function tileKey(x, y, z = Z) {
  return `${z}:${x},${y}`;
}

function isEditableTarget(target) {
  if (!target) return false;
  const tag = (target.tagName || '').toLowerCase();
  return tag === 'input' || tag === 'textarea' || tag === 'select' || target.isContentEditable;
}

function setCanvasSize() {
  const rect = canvas.getBoundingClientRect();
  canvas.width = Math.max(1, Math.round(rect.width * dpr));
  canvas.height = Math.max(1, Math.round(rect.height * dpr));
}

function draw() {
  const rect = canvas.getBoundingClientRect();
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  ctx.clearRect(0, 0, rect.width, rect.height);

  const scale = Math.pow(2, zoom);
  const spacing = TILE_SIZE * scale;

  ctx.strokeStyle = 'rgba(0,0,0,0.25)';
  ctx.lineWidth = 1;

  let startX = originX % spacing;
  if (startX < 0) startX += spacing;
  for (let x = startX; x <= rect.width; x += spacing) {
    ctx.beginPath();
    ctx.moveTo(Math.round(x) + 0.5, 0);
    ctx.lineTo(Math.round(x) + 0.5, rect.height);
    ctx.stroke();
  }

  let startY = originY % spacing;
  if (startY < 0) startY += spacing;
  for (let y = startY; y <= rect.height; y += spacing) {
    ctx.beginPath();
    ctx.moveTo(0, Math.round(y) + 0.5);
    ctx.lineTo(rect.width, Math.round(y) + 0.5);
    ctx.stroke();
  }

  tiles.forEach((tileInfo, key) => {
    const sx = Math.round(originX + tileInfo.x * TILE_SIZE * scale);
    const sy = Math.round(originY + tileInfo.y * TILE_SIZE * scale);
    const size = Math.round(TILE_SIZE * scale);

    let img = tileInfo.img;
    if (activeAnimation && activeAnimation.key === key) {
      const frame = activeAnimation.frames[activeAnimation.frameIndex];
      if (frame) {
        img = frame;
      }
    }

    ctx.drawImage(img, sx, sy, size, size);

    const info = animationManifest.get(key);
    if (info && info.animated) {
      const radius = Math.max(3, Math.min(6, size * 0.15));
      ctx.fillStyle = 'rgba(255,165,0,0.85)';
      ctx.beginPath();
      ctx.arc(sx + radius * 1.5, sy + radius * 1.5, radius, 0, Math.PI * 2);
      ctx.fill();
    }
  });

  const rectToDraw = selectionRect || highlightRect;
  if (rectToDraw) {
    const baseX = originX + rectToDraw.x * TILE_SIZE * scale;
    const baseY = originY + rectToDraw.y * TILE_SIZE * scale;
    const w = rectToDraw.width * TILE_SIZE * scale;
    const h = rectToDraw.height * TILE_SIZE * scale;
    ctx.fillStyle = generating ? 'rgba(79,140,255,0.15)' : 'rgba(79,140,255,0.25)';
    ctx.strokeStyle = generating ? 'rgba(79,140,255,0.7)' : 'rgba(79,140,255,0.85)';
    ctx.lineWidth = Math.max(1, Math.min(3, scale));
    ctx.fillRect(baseX, baseY, w, h);
    ctx.strokeRect(baseX + 0.5, baseY + 0.5, w, h);
  }
}

function updateButtons() {
  const singleTile = !!(highlightRect && highlightRect.width === 1 && highlightRect.height === 1);
  const key = singleTile ? tileKey(highlightRect.x, highlightRect.y, Z) : null;
  const info = key ? animationManifest.get(key) : null;
  const playing = !!(activeAnimation && key && activeAnimation.key === key);

  animateBtn.disabled = animationBusy || generating || !singleTile;
  playBtn.textContent = playing ? 'Stop' : 'Play';

  if (playing) {
    playBtn.disabled = false;
  } else {
    const canPlay = !!(singleTile && info && info.animated && Array.isArray(info.frame_urls) && info.frame_urls.length);
    playBtn.disabled = !canPlay || animationBusy || generating;
  }
}

function stopAnimation() {
  if (animationFrameHandle !== null) {
    cancelAnimationFrame(animationFrameHandle);
    animationFrameHandle = null;
  }
  if (activeAnimation) {
    activeAnimation = null;
    draw();
  }
  updateButtons();
}

function clearAnimations() {
  animationManifest.clear();
  animationFrames.clear();
  stopAnimation();
}

function animationTick(timestamp) {
  if (!activeAnimation) {
    animationFrameHandle = null;
    return;
  }
  if (!activeAnimation.lastSwitch) {
    activeAnimation.lastSwitch = timestamp;
  }
  if (timestamp - activeAnimation.lastSwitch >= activeAnimation.frameDuration) {
    activeAnimation.frameIndex = (activeAnimation.frameIndex + 1) % activeAnimation.frames.length;
    activeAnimation.lastSwitch = timestamp;
  }
  draw();
  animationFrameHandle = requestAnimationFrame(animationTick);
}

function startAnimation(key, frames, durationMs) {
  stopAnimation();
  if (!frames || !frames.length) return;
  activeAnimation = {
    key,
    frames,
    frameIndex: 0,
    frameDuration: Math.max(30, durationMs || DEFAULT_FRAME_MS),
    lastSwitch: 0
  };
  animationFrameHandle = requestAnimationFrame(animationTick);
  updateButtons();
  draw();
}

async function ensureAnimationFrames(key, info) {
  const cached = animationFrames.get(key);
  const expectedCount = info?.frame_count || FRAME_COUNT;
  if (cached && cached.version === info.version && cached.frames && cached.frames.length === expectedCount) {
    return cached.frames;
  }
  const urls = Array.isArray(info?.frame_urls) ? info.frame_urls : [];
  if (!urls.length) throw new Error('No frame URLs');
  const frames = await Promise.all(
    urls.map((url, idx) => new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = () => reject(new Error(`frame ${idx} failed to load`));
      const bust = url.includes('?') ? '&' : '?';
      img.src = `${url}${bust}r=${Date.now()}`;
    }))
  );
  animationFrames.set(key, { frames, version: info.version });
  return frames;
}

function applyAnimationUpdate(info) {
  if (!info || typeof info !== 'object') return;
  const key = tileKey(info.x, info.y, info.z ?? Z);
  if (info.animated) {
    animationManifest.set(key, { ...info });
    animationFrames.delete(key);
  } else {
    animationManifest.delete(key);
    animationFrames.delete(key);
    if (activeAnimation && activeAnimation.key === key) {
      stopAnimation();
    }
  }
  if (
    highlightRect &&
    highlightRect.width === 1 &&
    highlightRect.height === 1 &&
    key === tileKey(highlightRect.x, highlightRect.y, Z) &&
    info &&
    typeof info.prompt === 'string' &&
    info.prompt.trim()
  ) {
    lastAnimationPrompt = info.prompt;
  }
  updateButtons();
  draw();
}

async function refreshAnimations() {
  try {
    const res = await fetch(`/maps/${MAP_ID}/animations`);
    if (!res.ok) return;
    const data = await res.json().catch(() => null);
    if (!data || !Array.isArray(data.animations)) return;
    const seen = new Set();
    data.animations.forEach(info => {
      const key = tileKey(info.x, info.y, info.z ?? Z);
      seen.add(key);
      if (info.animated) {
        animationManifest.set(key, { ...info });
      } else {
        animationManifest.delete(key);
      }
      animationFrames.delete(key);
      if (
        highlightRect &&
        highlightRect.width === 1 &&
        highlightRect.height === 1 &&
        key === tileKey(highlightRect.x, highlightRect.y, Z) &&
        info &&
        typeof info.prompt === 'string' &&
        info.prompt.trim()
      ) {
        lastAnimationPrompt = info.prompt;
      }
    });
    Array.from(animationManifest.keys()).forEach(key => {
      if (!seen.has(key)) {
        animationManifest.delete(key);
        animationFrames.delete(key);
      }
    });
    if (activeAnimation && !animationManifest.has(activeAnimation.key)) {
      stopAnimation();
    } else {
      updateButtons();
      draw();
    }
  } catch (err) {
    console.warn('animation refresh failed', err);
  }
}

async function loadTiles(infos) {
  if (!Array.isArray(infos) || !infos.length) return;
  const tasks = infos.map(info => new Promise(resolve => {
    if (!info || typeof info !== 'object' || !info.url) {
      resolve();
      return;
    }
    const img = new Image();
    img.onload = () => {
      const key = tileKey(info.x, info.y, info.z ?? Z);
      tiles.set(key, { img, x: info.x, y: info.y, z: info.z ?? Z });
      resolve();
    };
    img.onerror = () => {
      console.warn('tile load failed', info);
      resolve();
    };
    const src = info.url;
    const bust = src.includes('?') ? '&' : '?';
    img.src = `${src}${bust}t=${Date.now()}`;
  }));
  await Promise.all(tasks);
}

async function hydrateExisting() {
  try {
    const res = await fetch(`/maps/${MAP_ID}/tiles/${Z}`);
    if (res.ok) {
      const data = await res.json().catch(() => null);
      if (data && Array.isArray(data.tiles)) {
        await loadTiles(data.tiles);
      }
    }
  } catch (err) {
    console.warn('hydrate failed', err);
  }
  await refreshAnimations();
  draw();
}

function tileFromClient(clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  const mx = clientX - rect.left;
  const my = clientY - rect.top;
  const scale = Math.pow(2, zoom);
  const wx = (mx - originX) / scale;
  const wy = (my - originY) / scale;
  return { x: Math.floor(wx / TILE_SIZE), y: Math.floor(wy / TILE_SIZE) };
}

function updateSelection(current) {
  if (!selectionStart) return;
  const maxOffset = MAX_SELECTION - 1;
  const dx = Math.max(-maxOffset, Math.min(maxOffset, current.x - selectionStart.x));
  const dy = Math.max(-maxOffset, Math.min(maxOffset, current.y - selectionStart.y));
  const endX = selectionStart.x + dx;
  const endY = selectionStart.y + dy;
  const minX = Math.min(selectionStart.x, endX);
  const minY = Math.min(selectionStart.y, endY);
  const width = Math.abs(endX - selectionStart.x) + 1;
  const height = Math.abs(endY - selectionStart.y) + 1;
  selectionRect = { x: minX, y: minY, width, height };
}

function pointInRect(pt, rect) {
  if (!rect) return false;
  return pt.x >= rect.x && pt.y >= rect.y && pt.x < rect.x + rect.width && pt.y < rect.y + rect.height;
}

function finalizeSelection() {
  const previousKey = highlightRect && highlightRect.width === 1 && highlightRect.height === 1
    ? tileKey(highlightRect.x, highlightRect.y, Z)
    : null;
  const rect = selectionRect ? { ...selectionRect } : null;
  selecting = false;
  selectionStart = null;
  selectionRect = null;
  highlightRect = rect;
  const newKey = rect && rect.width === 1 && rect.height === 1
    ? tileKey(rect.x, rect.y, Z)
    : null;
  if (newKey) {
    const info = animationManifest.get(newKey);
    if (info && typeof info.prompt === 'string' && info.prompt.trim()) {
      lastAnimationPrompt = info.prompt;
    }
  }
  if (activeAnimation && previousKey !== newKey) {
    stopAnimation();
  } else {
    updateButtons();
    draw();
  }
}

async function requestGeneration(rect, del = false) {
  const copy = { ...rect };
  let text = '';
  if (!del) {
    const promptText = window.prompt(`Prompt for ${copy.width}x${copy.height}`, lastPrompt);
    if (promptText === null) {
      draw();
      return;
    }
    text = promptText.trim();
    if (text) lastPrompt = text;
  }
  highlightRect = copy;
  generating = true;
  updateButtons();
  draw();
  try {
    const res = await fetch(`/maps/${MAP_ID}/generate`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        x: copy.x,
        y: copy.y,
        width: copy.width,
        height: copy.height,
        z: Z,
        prompt: text,
        delete: del
      })
    });
    const json = await res.json().catch(() => null);
    if (!res.ok || !json || json.ok !== true) {
      alert('Generation failed');
      return;
    }
    if (Array.isArray(json.tiles) && json.tiles.length) {
      await loadTiles(json.tiles);
    }
    if (Array.isArray(json.removed) && json.removed.length) {
      json.removed.forEach(t => {
        const tz = typeof t.z === 'number' ? t.z : Z;
        const k = tileKey(t.x, t.y, tz);
        tiles.delete(k);
        animationManifest.delete(k);
        animationFrames.delete(k);
      });
    }
    await refreshAnimations();
  } catch (err) {
    alert('Generation error');
  } finally {
    highlightRect = null;
    generating = false;
    updateButtons();
    draw();
  }
}

function handleMapSwitch(id) {
  if (!id) return;
  MAP_ID = id;
  tiles.clear();
  selectionRect = null;
  selectionStart = null;
  highlightRect = null;
  generating = false;
  clearAnimations();
  updateButtons();
  draw();
  hydrateExisting();
}

async function refreshMaps() {
  try {
    const res = await fetch('/maps');
    if (!res.ok) return;
    const data = await res.json().catch(() => null);
    if (!data || !Array.isArray(data.maps)) return;
    mapSelect.innerHTML = '';
    const sorted = [...data.maps].sort();
    let hasCurrent = false;
    sorted.forEach(id => {
      const option = document.createElement('option');
      option.value = id;
      option.textContent = id;
      if (id === MAP_ID) {
        option.selected = true;
        hasCurrent = true;
      }
      mapSelect.appendChild(option);
    });
    if (!hasCurrent && sorted.length) {
      handleMapSwitch(sorted[0]);
      mapSelect.value = sorted[0];
    }
  } catch (err) {
    console.error('map refresh failed', err);
  }
}

animateBtn.addEventListener('click', async () => {
  if (animateBtn.disabled) return;
  if (!highlightRect || highlightRect.width !== 1 || highlightRect.height !== 1) {
    alert('Select a single tile first');
    return;
  }
  const prompt = window.prompt('Animation prompt', lastAnimationPrompt);
  if (prompt === null) return;
  const trimmed = prompt.trim();
  if (!trimmed) {
    alert('Prompt required');
    return;
  }
  lastAnimationPrompt = trimmed;
  let durationInput = window.prompt('Frame duration in ms (default 120)', String(DEFAULT_FRAME_MS));
  if (durationInput === null) return;
  let frameDuration = parseInt(durationInput, 10);
  if (!Number.isFinite(frameDuration) || frameDuration <= 0) {
    frameDuration = DEFAULT_FRAME_MS;
  }
  animationBusy = true;
  updateButtons();
  try {
    const payload = {
      x: highlightRect.x,
      y: highlightRect.y,
      z: Z,
      frame_count: FRAME_COUNT,
      frame_duration_ms: frameDuration,
      prompt: trimmed
    };
    const res = await fetch(`/maps/${MAP_ID}/animations`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    const json = await res.json().catch(() => null);
    if (!res.ok || !json || json.ok !== true) {
      alert('Animation failed');
      return;
    }
    if (json.tile) {
      await loadTiles([json.tile]);
    }
    if (json.animation) {
      applyAnimationUpdate(json.animation);
    }
  } catch (err) {
    console.error('animation request failed', err);
    alert('Animation failed');
  } finally {
    animationBusy = false;
    updateButtons();
    draw();
  }
});

playBtn.addEventListener('click', async () => {
  if (playBtn.disabled) return;
  if (!highlightRect || highlightRect.width !== 1 || highlightRect.height !== 1) {
    alert('Select a single tile first');
    return;
  }
  const key = tileKey(highlightRect.x, highlightRect.y, Z);
  if (activeAnimation && activeAnimation.key === key) {
    stopAnimation();
    return;
  }
  const info = animationManifest.get(key);
  if (!info || !info.animated) {
    alert('No animation for this tile');
    return;
  }
  try {
    playBtn.disabled = true;
    const frames = await ensureAnimationFrames(key, info);
    startAnimation(key, frames, info.frame_duration_ms || DEFAULT_FRAME_MS);
  } catch (err) {
    console.error('play animation failed', err);
    alert('Unable to load animation frames');
  } finally {
    updateButtons();
  }
});

window.addEventListener('resize', () => {
  setCanvasSize();
  draw();
});

window.addEventListener('keydown', e => {
  if (isEditableTarget(e.target)) return;
  if (e.code === 'Space') {
    if (!isSpaceDown) e.preventDefault();
    isSpaceDown = true;
  }
  if (e.key === 'Escape') {
    if (selecting) {
      selecting = false;
      selectionRect = null;
      selectionStart = null;
    } else {
      highlightRect = null;
    }
    stopAnimation();
    updateButtons();
    draw();
  }
});

window.addEventListener('keyup', e => {
  if (isEditableTarget(e.target)) return;
  if (e.code === 'Space') isSpaceDown = false;
});

canvas.addEventListener('mousedown', e => {
  if ((e.button === 0 && isSpaceDown) || e.button === 1 || e.button === 2) {
    panActive = true;
    lastX = e.clientX;
    lastY = e.clientY;
    e.preventDefault();
    return;
  }
  if (e.button !== 0) return;
  const pt = tileFromClient(e.clientX, e.clientY);
  if (highlightRect) {
    if (pointInRect(pt, highlightRect)) {
      requestGeneration(highlightRect);
      e.preventDefault();
      return;
    }
    highlightRect = null;
    stopAnimation();
    updateButtons();
    draw();
    e.preventDefault();
    return;
  }
  selecting = true;
  selectionStart = pt;
  selectionRect = { x: pt.x, y: pt.y, width: 1, height: 1 };
  draw();
  e.preventDefault();
});

window.addEventListener('mousemove', e => {
  if (panActive) {
    originX += e.clientX - lastX;
    originY += e.clientY - lastY;
    lastX = e.clientX;
    lastY = e.clientY;
    draw();
    return;
  }
  if (!selecting) return;
  updateSelection(tileFromClient(e.clientX, e.clientY));
  draw();
});

window.addEventListener('mouseup', e => {
  if (panActive && (e.button === 0 || e.button === 1 || e.button === 2)) {
    panActive = false;
  }
  if (selecting && e.button === 0) {
    finalizeSelection();
  }
});

canvas.addEventListener('contextmenu', e => e.preventDefault());

canvas.addEventListener('wheel', e => {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  const prevScale = Math.pow(2, zoom);
  const step = e.deltaY < 0 ? 0.25 : -0.25;
  zoom = Math.min(6, Math.max(-6, zoom + step));
  const scale = Math.pow(2, zoom);
  originX = mx - (mx - originX) * (scale / prevScale);
  originY = my - (my - originY) * (scale / prevScale);
  draw();
}, { passive: false });

document.getElementById('createBtn').onclick = async () => {
  const input = document.getElementById('newMap');
  const value = (input.value || '').trim().toLowerCase();
  if (!/^[a-z]{4}$/.test(value)) {
    alert('4 letters');
    return;
  }
  const res = await fetch('/maps', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ map_id: value })
  });
  const json = await res.json().catch(() => ({ ok: false }));
  if (json.ok) {
    input.value = '';
    await refreshMaps();
    handleMapSwitch(value);
  }
};

document.getElementById('deleteBtn').onclick = async () => {
  if (!highlightRect) {
    alert('No selection');
    return;
  }
  const ok = window.confirm('Delete selected tiles?');
  if (!ok) return;
  await requestGeneration(highlightRect, true);
};

mapSelect.onchange = () => {
  handleMapSwitch(mapSelect.value);
};

setCanvasSize();
draw();
updateButtons();
refreshMaps();
hydrateExisting();
</script>
</body>
</html>
